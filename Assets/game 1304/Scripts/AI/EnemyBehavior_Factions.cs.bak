using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEditor;
using UnityEngine.Serialization;

public enum OOIFrameOfReference { direct, indirect};

[Serializable]
public class Behavior
{
    public BehaviorType behaviorType;
    public GameObject behaviorTarget;
    public float priority;

    public Behavior(BehaviorType bt, GameObject target)
    {
        behaviorType = bt;
        behaviorTarget = target;
    }
}

[Serializable]
public class factionRelationshipChangeEventEntry
{
    public string eventName;
    public factionRelationship newRelationship;
}

[Serializable]
public class OOIProfile
{
    public ObjectOfInterest OOI;

    public float awarenessLevel;
    public float priority = 0;
    public OOICategory category;
    public bool isVisible;
    public OOIFrameOfReference frameOfReference;
    public bool isPsychicallyAware = false;
    public Attitude attitude;
}

[RequireComponent(typeof(ObjectOfInterest))]

public class EnemyBehavior_Factions : MonoBehaviour
{
    [Header("Mortality")]
    public GameObject objectToDrop;
    public int maxHealth = 100;
    private int _currentHealth;
    public bool ragdollOnDeath = true;
    public List<eventPackage> eventsToSendOnDeath;
    public List<healthThresholdData> healthLevelChanges;    
    public bool isAlive
    {
        get
        {
            return (_currentHealth > 0);
        }
    }
    public List<signalEventEntry> damageEvents;
    public List<damageMultiplier> damageTypeMultipliers;
    public bool isInvincible = false;
    [Space(5)]
    [Header("Movement")]
    public float patrolSpeed = 5.0f;
    public float investigateSpeed = 7.0f;
    public float attackingSpeed = 10.0f;
    public float fleeingSpeed = 10.0f;
    private bool isFlying = false;

    [Space(5)]
    [Header("Factions")]
    public static GameObject factionDatabase;
    

    [Space(5)]
    [Header("Behavior")]
    
    public BehaviorType startingBehavior;
    public BehaviorType currentBehavior { get { return _currentBehavior; } }
    public GameObject behaviorTarget = null;
    [Tooltip("Events that will change this NPC's behavior")]
    public List<behaviorChangeEventEntry> behaviorChangeEvents;
    public Faction faction;
    private FactionDef myFactionDef;
    public List<factionRelationship> relationshipOverrides;
    public List<factionRelationshipChangeEventEntry> factionOverrideEvents;
    private BehaviorType _currentBehavior, _previousBehavior, _behaviorLastFrame;
    
    private Stack<Behavior> behaviorStack;

    [Space(2)]
    public GameObject followFleeTarget;
    public float followDistance = 5.0f;
    public List<followTargetChangeEventEntry> followDifferentTargetEvents;

    [Space(2)]
    [Tooltip("Nav container object that contains this character's patrol information")]
    public List<patrolChangeEventEntry> patrolRouteChangeEvents;
    public NavPointContainer navContainerObject;
    private List<navPoint> navPoints;
    private NavMeshAgent agent;
    private FlyingLocomotionBehavior flyBehavior;
    private Vector3 fleeDestination;
    private int currentPointIndex;
    private int patrolEventsToFireIndex;
    private int pointCount;
    private navBehavior patrolType;
    private int pingPongDir = 1;
    private float patrolWaitTimer = 0f;


    [Space(5)]
    [Header("Attacking")]
    public NPCAttackType attackType = NPCAttackType.touch;
    public GameObject bulletPrefab;
    [Tooltip("The time between acquiring a target and attacking. Min-max range.")]
    public int attackWindupMax;
    [Tooltip("The time between acquiring a target and attacking. Min-max range.")]
    public int attackWindupMin;
    [Tooltip("The time between attacks. Min-max range.")]
    public int attackcoolDownMin;
    [Tooltip("The time between attacks. Min-max range.")]
    public int attackcoolDownMax;
    [Tooltip("Only used if attack mode is ranged. Set to 0 for unlimited range.")]
    public float rangedAttackMaxDistance = 10f;
    [Tooltip("Only used if attack mode is ranged.")]
    public float rangedAttackMinDistance = 0f;    
    public AudioClip rangedAttackSound;
    public AudioClip meleedAttackSound;
    private float currentAttackCooldown = 0f;
    private bool reacquiringTarget;
    private Vector3 reacquireDestination;

    [Space(5)]
    [Header("Suspicion")]
    public float awarenessMeterUnawareToInvestigate = 5.0f;
    public float awarenessMeterInvestigateToBusted = 7.5f;
    public float idleSenseRate = 5.0f;
    public float suspiciousSenseRate = 10.0f;
    public float veryNearSenseMultiplier = 5f;
    public float nearSenseMultiplier = 2f;
    public float farSenseMultiplier = 0.75f;
    public float veryFarSenseMultiplier = 0.5f;
    public float senseBleedOffRate = 1.0f;
    
    public float maximumSuspicion = 15f;
    [Tooltip("This means that the AI will always know where the player is and won't lose track.")]
    public bool hasPsychicAwarenessOfPlayer = false;
    public AudioClip soundToPlayOnBusted;    
    public GameObject suspicionIndicator;
    public GameObject alertedIndicator;
    private float currentSuspicion = 0;
    private List<OOIProfile> objectsOfInterest;
    private OOIProfile currentObjectOfFocus;
    private AudioSource enemyAudioSource;

    [Space(5)]
    [Header("Senses")]
    public float patrolFOV = 100.0f;
    public float investigateFOV = 110.0f;
    public float pursuitFOV = 130.0f;
    //TODO: add peripheral cone    
    public Vector3 personalLastSighting;            
    public List<visionRangeChangeEventEntry> visionRadiusChangeEvents;
    private SphereCollider visionSphere;
    private Vector3 previousSighting;
    private GameObject player;

    [Space(5)]
    [Header("Fleeing")]
    public float fleeRadius = 5.0f;
    public List<GameObject> fleePoints;
    private GameObject nextFleeTarget, currentFleeTarget;

    [Space(5)]
    [Header("Distractions")]
    public float distractionCooldownMin = 5f;
    public float distractionCooldownMax = 10f;
    private NPCDistractor currentDistraction;
    private float currentDistractionCooldown = 0f;
    private float distractionWaitTimer = 0f;

    [Space(10)]
    [Header("Deprecated")]
    public Attitude attitudeTowardsPlayer = Attitude.neutral;
    [Tooltip("Events that will change how this NPC reacts to the player")]
    public List<attitudeChangeEventEntry> attitudeChangeEvents;    
    public List<string> eventsToFireOnDeath;    
    public bool playerInSight { get { return _playerInSight; } }
    private bool _playerInSight;

    //framerate savers
    int timer = 0;
    int interval = 4;

    void initFactions()
    {
        foreach (FactionDef fd in NPCManager.factionDefinitions)
        {
            if (fd.faction == faction)
            {
                myFactionDef = fd;
            }
        }
    }

  

    void Awake()
    {
        ObjectOfInterest tempoi;
        //TODO: replace with the real deal later
        tempoi = GetComponent<ObjectOfInterest>();

        if (tempoi != null)
            tempoi.visibility = 1;
        //Initialize everything
        NPCManager.registerAI(this);
        Invoke("initFactions", 0.1f);
        
        _currentHealth = maxHealth;
        _currentBehavior = startingBehavior;


        updatePlayerRef();

        enemyAudioSource = GetComponent<AudioSource>();

        //TODO: replace with creation of vision sphere
        foreach (SphereCollider sc in GetComponents<SphereCollider>())
        {
            if (sc.isTrigger == true)
                visionSphere = sc;
        }

        //Hide the indicators for the NPCs suspicion
        HelperFunctions.hideObjectAndChildren(suspicionIndicator);
        HelperFunctions.hideObjectAndChildren(alertedIndicator);

        agent = GetComponent<NavMeshAgent>();
        if (agent == null)
        {
            flyBehavior = GetComponent<FlyingLocomotionBehavior>();
            if (flyBehavior != null)
                isFlying = true;
        }
        setPatrol(navContainerObject);

        behaviorStack = new Stack<Behavior>();
        behaviorStack.Push(new Behavior(BehaviorType.idle, null));
        setBehavior(startingBehavior,null);
        //TODO: Just use SetBehavior for this and let it do the heavy lifting
        /*switch (_currentBehavior)
        {
            case BehaviorType.attacking:
                setAgentSpeed(attackingSpeed);                
                break;
            case BehaviorType.patrolling:
                setAgentSpeed(patrolSpeed);                
                GoToNextPoint();
                break;
            case BehaviorType.following:
                setAgentSpeed(patrolSpeed);
                setAgentDestination(followFleeTarget.transform.position);                
                InvokeRepeating("followTarget", 0f, 0.25f);
                break;
            case BehaviorType.fleeing:
                setAgentSpeed(fleeingSpeed);                
                break;
        }

        _previousBehavior = BehaviorType.none;*/
        _behaviorLastFrame = BehaviorType.none;
        _playerInSight = false; // hasPsychicAwarenessOfPlayer;
        if (hasPsychicAwarenessOfPlayer)
            currentSuspicion = awarenessMeterInvestigateToBusted;
        objectsOfInterest = new List<OOIProfile>();
        currentObjectOfFocus = new OOIProfile();
        currentObjectOfFocus.awarenessLevel = 0;
        currentObjectOfFocus.category = OOICategory.unknown;
        currentObjectOfFocus.isVisible = false;
        currentObjectOfFocus.OOI = null;

    }
    
    //drawing vision cones
    //TODO: Make this work
    private void OnDrawGizmos()
    {
#if UNITY_EDITOR
        if (Application.isPlaying)
        {
            Gizmos.color = Color.white;            
            Gizmos.DrawWireSphere(reacquireDestination, 1);
            /*  foreach (SphereCollider sc in GetComponents<SphereCollider>())
              {
                  if (sc.isTrigger == true)
                      visionSphere = sc;
              }
              Gizmos.matrix = Matrix4x4.Rotate(Quaternion.Euler(transform.forward));
              Gizmos.DrawFrustum(transform.position, 45, visionSphere.radius, 0, 1.5f);

           */
#endif
        }
    }

    private void OnDrawGizmosSelected()
    {
#if UNITY_EDITOR
        if (navContainerObject != null)
        {
            Handles.color = Color.blue;
            Handles.DrawDottedLine(transform.position, navContainerObject.gameObject.transform.position, 2.0f);
            navContainerObject.drawPatrolGizmos();
        }
#endif
    }


    void Start()
    {
        //register all the event management hooks
        foreach (attitudeChangeEventEntry acee in attitudeChangeEvents)
        {
            if (acee.eventName != "")
                EventRegistry.AddEvent(acee.eventName, changeAttitudeOnEvent);
        }
        foreach (behaviorChangeEventEntry bcee in behaviorChangeEvents)
        {
            if (bcee.eventName != "")
                EventRegistry.AddEvent(bcee.eventName, changeBehaviorOnEvent);
        }
        foreach (followTargetChangeEventEntry bcee in followDifferentTargetEvents)
        {
            if (bcee.eventName != "")
                EventRegistry.AddEvent(bcee.eventName, changeFollowTargetEvent);
        }
        foreach (visionRangeChangeEventEntry vcee in visionRadiusChangeEvents)
        {
            if (vcee.eventName != "")
                EventRegistry.AddEvent(vcee.eventName, changeVisionRangeEvent);
        }
        foreach (patrolChangeEventEntry pcee in patrolRouteChangeEvents)
        {
            if (pcee.eventName != "")
                EventRegistry.AddEvent(pcee.eventName, patrolChangeEvent);
        }

    }

    public void changeBehaviorOnEvent(string eventName, GameObject obj)
    {
        if ((obj != null) && (obj != this.gameObject))
            return;
        foreach (behaviorChangeEventEntry bcee in behaviorChangeEvents)
        {
            if (bcee.eventName == eventName)
            {
                setBehavior(bcee.behaviorToChangeTo,null);
            }
        }
    }

    public void changeAttitudeOnEvent(string eventName, GameObject obj)
    {
        if ((obj != null) && (obj != this.gameObject))
            return;
        foreach (attitudeChangeEventEntry ace in attitudeChangeEvents)
        {
            if (ace.eventName == eventName)
            {
                setAttitude(ace.attitudeToChangeTo);
                //attitudeTowardsPlayer = ace.attitudeToChangeTo;
                //setAttitude(ace.attitudeToChangeTo);
            }
        }
    }

    public void changeFollowTargetEvent(string eventName, GameObject obj)
    {
        if ((obj != null) && (obj != this.gameObject))
            return;
        foreach (followTargetChangeEventEntry ftce in followDifferentTargetEvents)
        {
            if (ftce.eventName == eventName)
            {
                followFleeTarget = ftce.newFollowTarget;
            }
        }
    }

    public void changeVisionRangeEvent(string eventName, GameObject obj)
    {
        if ((obj != null) && (obj != this.gameObject))
            return;
        foreach (visionRangeChangeEventEntry vce in visionRadiusChangeEvents)
        {
            if ((vce.eventName == eventName) && (visionSphere != null))
            {
                visionSphere.radius = vce.newVisionRange;
            }
        }
    }

    public void patrolChangeEvent(string eventName, GameObject obj)
    {
        if ((obj != null) && (obj != this.gameObject))
            return;
        foreach (patrolChangeEventEntry pce in patrolRouteChangeEvents)
        {
            if (pce.eventName == eventName)
            {
                setPatrol(pce.navContainerObject, pce.patrolSwitchBehavior);
                if (behaviorStack.Peek().behaviorType == BehaviorType.patrolling)
                    GoToNextPoint();
            }
        }
    }

    private void setPatrol(NavPointContainer navContainer, PatrolSwitchBehaviorType psb = PatrolSwitchBehaviorType.pickFirst)
    { //Patrol stuff
        int psbIndex = 0;
        int oldNavIndex = currentPointIndex;
        NavPointContainer npc = null;
        if (navContainer != null)
            npc = navContainer.GetComponent<NavPointContainer>();
        else
        {
            _currentBehavior = BehaviorType.idle;
            return;
        }
        if (npc != null)
        {
            if (npc.navPoints != null)
            {
                navPoints = npc.navPoints;
                if (navPoints.Count == 0)
                {
                    _currentBehavior = BehaviorType.idle;
                    return;
                }
                patrolType = npc.navigationBehaviorType;
            }
            else
            {
                _currentBehavior = BehaviorType.idle;
                return;
            }
        }
        else
        {
            _currentBehavior = BehaviorType.idle;
            return;
        }
        
        switch (psb)
        {
            case PatrolSwitchBehaviorType.pickFirst:
                psbIndex = 0;
                break;
            case PatrolSwitchBehaviorType.pickClosest:
                int counter = -1;
                int closestIndex = 0;
                float dist = 0f;
                float closestDistance = 1000000.0f;
                foreach (navPoint np in navPoints)
                {
                    counter++;
                    dist = Vector3.Distance(np.navPointObject.transform.position, gameObject.transform.position);
                    if (dist < closestDistance)
                    {
                        closestIndex = counter;
                        closestDistance = dist;
                    }
                }
                psbIndex = closestIndex;
                break;
            case PatrolSwitchBehaviorType.pickRandom:
                psbIndex = UnityEngine.Random.Range(0, navPoints.Count);
                break;
            case PatrolSwitchBehaviorType.pickSimilarIndex:
                psbIndex = oldNavIndex % navPoints.Count;
                break;
        }

        if (patrolType == navBehavior.wander)
            currentPointIndex = UnityEngine.Random.Range(0, navPoints.Count);
        else
            currentPointIndex = psbIndex;

    }

    //TODO: replace with factional overrides
    public void setAttitude(Attitude newAttitude)
    {
        /*attitudeTowardsPlayer = newAttitude;
        if ((currentBehavior == BehaviorType.attacking) && ((attitudeTowardsPlayer == AttitudeType.friendly) || (attitudeTowardsPlayer == AttitudeType.neutral)))
            setBehavior(_previousBehavior);
        if (attitudeTowardsPlayer == AttitudeType.fearful)
            setBehavior(BehaviorType.fleeing);

        if ((attitudeTowardsPlayer == AttitudeType.friendly) || (attitudeTowardsPlayer == AttitudeType.neutral))
            wipeSuspicion();*/
    }

    //Add to list of OOIs that the NPC has constant awareness of
    //TODO: fill in
    public void addPsychicAwarenessTarget()
    {

    }

    void updateBehaviorInfluences(BehaviorType oldType, BehaviorType newType)
    {
        if (oldType == BehaviorType.following)
            CancelInvoke();
        if(oldType == BehaviorType.attacking)
        {
            reacquiringTarget = false;
            setAgentStopped(true);
        }
        if (newType == BehaviorType.attacking)
        {
            currentSuspicion = awarenessMeterInvestigateToBusted;
        }
        if (newType != BehaviorType.following)
        {
            if (oldType == BehaviorType.following)
                CancelInvoke();
        }
        if (newType == BehaviorType.following)
        {
            if (oldType != BehaviorType.following)
            {
                setAgentSpeed(patrolSpeed);
                setAgentDestination(followFleeTarget.transform.position);
                InvokeRepeating("followTarget", 0f, 0.25f);
            }
        }
        if (newType != BehaviorType.fleeing)
        {
            if (oldType == BehaviorType.fleeing)
                CancelInvoke();
        }
        if (newType == BehaviorType.idle)
        {
            setAgentStopped(true);
        }
        if ((newType == BehaviorType.patrolling) && (oldType != BehaviorType.patrolling))
        {
            setAgentSpeed(patrolSpeed);
            //setPatrol(navContainerObject);
            GoToNextPoint();
        }
    }

    void popBehaviorStack()
    {
        Behavior oldBehavior = behaviorStack.Pop();
        updateBehaviorInfluences(oldBehavior.behaviorType, behaviorStack.Peek().behaviorType);
    }
    public void setBehavior(BehaviorType newBehavior, GameObject target)
    {
        setBehavior(new Behavior(newBehavior, target));
    }

    public void setBehavior(Behavior newBehavior)
    {
        updateBehaviorInfluences(behaviorStack.Peek().behaviorType, newBehavior.behaviorType);
        //TODO: come back and work over this with state machine mentality                
        behaviorStack.Push(newBehavior);
    }

    public void Damage(int damageAmount, signalTypes damageType)
    {
        if (isInvincible)
            return;
        //TODO: add health change threshold events here
        //TODO: add suspicion/busted on damage source here
        GameObject dropObject;
        bool damagePassesEventCheck = false;
        if (_currentHealth <= 0)
            return;
        foreach (damageMultiplier dm in damageTypeMultipliers)
        {
            if (damageType == dm.damageType)
                damageAmount = (int)(damageAmount * dm.multiplier);
        }

        _currentHealth -= damageAmount;
        foreach (signalEventEntry dee in damageEvents)
        {
            damagePassesEventCheck = false;
            if (damageAmount >= dee.damageThreshold)
            {
                if (dee.filterByDamageType == false || ((dee.filterByDamageType) && (dee.damageType == damageType)))
                {
                    switch (dee.comparisonForThreshold)
                    {
                        case comparisonOperator.Equal:
                            damagePassesEventCheck = (dee.damageThreshold == damageAmount);
                            break;
                        case comparisonOperator.greaterThan:
                            damagePassesEventCheck = (damageAmount > dee.damageThreshold);
                            break;
                        case comparisonOperator.greaterThanEqual:
                            damagePassesEventCheck = (damageAmount >= dee.damageThreshold);
                            break;
                        case comparisonOperator.lessThan:
                            damagePassesEventCheck = (damageAmount < dee.damageThreshold);
                            break;
                        case comparisonOperator.lessThanEqual:
                            damagePassesEventCheck = (damageAmount <= dee.damageThreshold);
                            break;
                        case comparisonOperator.notEqual:
                            damagePassesEventCheck = (dee.damageThreshold != damageAmount);
                            break;
                    }
                    if (damagePassesEventCheck)
                    {
                        foreach (string s in dee.oldEventsToSend)
                            EventRegistry.SendEvent(s);
                        foreach (eventPackage ep in dee.eventsToSend)
                            EventRegistry.SendEvent(ep, this.gameObject);
                    }
                }
            }
        }
        if (_currentHealth <= 0)
        {
            HelperFunctions.hideObjectAndChildren(suspicionIndicator);
            HelperFunctions.hideObjectAndChildren(alertedIndicator);
            CancelInvoke();
            GetComponent<ObjectOfInterest>().isAlive = false;
            if (objectToDrop != null)
            {
                dropObject = Instantiate(objectToDrop);
                dropObject.transform.position = gameObject.transform.position;
            }
            if (visionSphere != null)
                Destroy(visionSphere);
            if (ragdollOnDeath)
            {
                setAgentEnabled(false);
                Rigidbody rb = gameObject.GetComponent<Rigidbody>();
                if (rb != null)
                {
                    if (isFlying)
                        rb.useGravity = true;
                    Vector3 currentVel = rb.velocity;
                    rb.isKinematic = false;
                    rb.AddRelativeTorque(new Vector3(30, 0, 0));
                    rb.AddForceAtPosition(transform.forward * 20 + new Vector3(0, 1, 0), transform.position + new Vector3(0, 0.5f, 0));
                }
                PhysicsCarryObject pco = gameObject.GetComponent<PhysicsCarryObject>();
                if (pco != null)
                {
                    pco.enabled = true;
                }
                setBehavior(BehaviorType.none, null);
            }
            else
                GameObject.Destroy(gameObject);
            foreach (string s in eventsToFireOnDeath)
            {
                EventRegistry.SendEvent(s);
            }
            foreach (eventPackage ep in eventsToSendOnDeath)
            {
                EventRegistry.SendEvent(ep,this.gameObject);
            }
        }
    }

    public void wipeSuspicion()
    {
        currentSuspicion = 0;
    }

    void Update()
    {
        if (timer % interval != 0)
        {
            timer++;
            return;
        }
        else
            timer=0;

        //paused or dead. Nothing to do here
        if ((GameManager.isPaused) || (_currentHealth <= 0))
            return;

        if (behaviorStack.Peek().behaviorType != BehaviorType.distracted)
        {
            currentDistractionCooldown -= Time.deltaTime;
            if (currentDistractionCooldown < 0)
                currentDistractionCooldown = 0;
        }


        if (currentAttackCooldown > 0)
        {
            currentAttackCooldown -= Time.deltaTime;
            if (currentAttackCooldown < 0)
                currentAttackCooldown = 0;
        }

        //TODO: start with is Attacking or not, then check FocusObject after looping through oois
        foreach (OOIProfile ooip in objectsOfInterest)
        {
            if ((ooip.isVisible || ooip.isPsychicallyAware))
            {
                //The target is in sight, but we aren't currently engaged with attacking them or running from them
                if ((behaviorStack.Peek().behaviorType != BehaviorType.attacking) && (behaviorStack.Peek().behaviorType != BehaviorType.fleeing))
                {
                    float targetDistance = getDistanceToTarget(ooip.OOI.transform);
                    float distanceMultiplier = 1f;
                    if (targetDistance >= visionSphere.radius * 0.75f)
                    {
                        distanceMultiplier = veryFarSenseMultiplier;
                    }

                    if ((targetDistance >= visionSphere.radius * 0.5f) && (targetDistance < visionSphere.radius * 0.75f))
                    {
                        distanceMultiplier = farSenseMultiplier;
                    }

                    if ((targetDistance >= visionSphere.radius * 0.25f) && (targetDistance < visionSphere.radius * 0.5f))
                    {
                        distanceMultiplier = nearSenseMultiplier;
                    }

                    if (targetDistance < visionSphere.radius * 0.25f)
                    {
                        distanceMultiplier = veryNearSenseMultiplier;
                    }

                    //TODO: add the concept of surprise
                    ooip.awarenessLevel += Time.deltaTime * idleSenseRate * distanceMultiplier * ooip.OOI.visibility; // * player.GetComponent<GAME1304PlayerController>().currentVisibility;

                    //TODO: make the whole priority system (combat threats take precedent over etc etc)
                    if (ooip.awarenessLevel > currentObjectOfFocus.awarenessLevel)
                        currentObjectOfFocus = ooip;
                    
                    if ((ooip.awarenessLevel >= awarenessMeterUnawareToInvestigate) && (ooip == currentObjectOfFocus))
                    {
                        if ((ooip.attitude == Attitude.hostile) || (ooip.attitude == Attitude.fearful))
                            HelperFunctions.showObjectAndChildren(suspicionIndicator);
                    }

                    if (ooip.awarenessLevel >= maximumSuspicion)
                        ooip.awarenessLevel = maximumSuspicion;

                    //TODO: find a better way to represent multiple objects of interest with multiple attitudes and behaviors towards each
                    if ((ooip.awarenessLevel > awarenessMeterInvestigateToBusted)&&(ooip == currentObjectOfFocus))
                    {
                        if ((ooip.attitude == Attitude.hostile) || (ooip.attitude == Attitude.fearful))
                        {
                            HelperFunctions.showObjectAndChildren(alertedIndicator);
                            HelperFunctions.hideObjectAndChildren(suspicionIndicator);
                        }
                      /*  if ((soundToPlayOnBusted != null) && (enemyAudioSource != null))
                        {
                            enemyAudioSource.clip = soundToPlayOnBusted;
                            enemyAudioSource.Play();
                        }*/
                        if ((ooip.attitude == Attitude.hostile)&&(ooip.OOI.isAlive))
                            setBehavior(BehaviorType.attacking,ooip.OOI.gameObject);
                        if ((ooip.attitude == Attitude.fearful)&&(ooip.OOI.isAlive))
                            setBehavior(BehaviorType.fleeing, ooip.OOI.gameObject);
                    }
                }
                
            }
            else
            {
                //target is out of sight, so cool down the suspicion meter

                //TODO: add different bleedoff rates depending on the character's level of engagement with a thing
                ooip.awarenessLevel -= Time.deltaTime * senseBleedOffRate;
                if (ooip.awarenessLevel < awarenessMeterInvestigateToBusted)
                {
                    if ((ooip.attitude == Attitude.hostile) || (ooip.attitude == Attitude.fearful))
                        HelperFunctions.showObjectAndChildren(suspicionIndicator);
                    HelperFunctions.hideObjectAndChildren(alertedIndicator);
                }

                if (ooip.awarenessLevel < awarenessMeterUnawareToInvestigate)
                {
                    HelperFunctions.hideObjectAndChildren(suspicionIndicator);
                }

                if (ooip.awarenessLevel < 0)
                    ooip.awarenessLevel = 0;

                if ((behaviorStack.Peek().behaviorType == BehaviorType.attacking) || (behaviorStack.Peek().behaviorType == BehaviorType.fleeing))

                {
                    //TODO: find a better way to represent multiple objects of interest with multiple attitudes and behaviors towards each
                    if ((ooip.awarenessLevel <= awarenessMeterUnawareToInvestigate)&& (ooip == currentObjectOfFocus))
                    {
                        HelperFunctions.hideObjectAndChildren(suspicionIndicator);
                        HelperFunctions.hideObjectAndChildren(alertedIndicator);
                        ooip.awarenessLevel = 0; //TODO: rethink this
                        popBehaviorStack();
                        CancelInvoke();
                    }
                }
            }
        }


        switch (behaviorStack.Peek().behaviorType)
        {
            case BehaviorType.idle: //do nothing, you're idle
                break;
            case BehaviorType.attacking:
                setAgentSpeed(attackingSpeed);
                //TODO: incorporate the actual attack types
                if (_behaviorLastFrame != BehaviorType.attacking)
                {
                    InvokeRepeating("chaseTarget", 0f, 0.25f);
                }
                break;
            case BehaviorType.fleeing:
                setAgentSpeed(fleeingSpeed);
                if (_behaviorLastFrame != BehaviorType.fleeing)
                {
                    setFleePoint();
                    //TODO: remove player from the equation. update to objects of interest, priority list, etc
                    InvokeRepeating("fleePlayer", 0f, 0.25f);
                }
                break;
            case BehaviorType.following:
                break;
            case BehaviorType.patrolling:
                /*if (_behaviorLastFrame != behaviorType.patrolling)
                {
                    setAgentSpeed(patrolSpeed);                    
                    HelperFunctions.hideObjectAndChildren(suspicionIndicator);
                    HelperFunctions.hideObjectAndChildren(alertedIndicator);
                    GoToNextPoint();
                }*/
                if (navPoints == null)
                {
                    Debug.Log("NULL navpoints in patrol");
                    setBehavior(BehaviorType.idle, null);
                }
                else
                {
                    if (currentPointIndex >= navPoints.Count)
                    {
                        Debug.Log("NULL navpoints in patrol");
                        setBehavior(BehaviorType.idle, null);
                    }
                    else
                    {
                        if (navPoints[currentPointIndex] == null)
                        {
                            Debug.Log("NULL navpoints in patrol");
                            setBehavior(BehaviorType.idle, null);
                        }
                    }
                }
                setAgentSpeed(patrolSpeed);
                if (!getAgentPathPending() && getAgentRemainingDistance() < 0.5f)
                {
                    patrolWaitTimer += Time.deltaTime;
                    if (patrolWaitTimer >= navPoints[currentPointIndex].pauseDuration)
                    {
                        //TODO: make this more efficient. take the assumptions out of the chain somewhere else
                        if (navPoints != null)
                        {
                            if (navPoints.Count > 0)
                            {
                                if (navPoints[patrolEventsToFireIndex] != null)
                                {
                                    if (navPoints[patrolEventsToFireIndex].eventsToFire.Count != 0)
                                    {
                                        foreach (string s in navPoints[patrolEventsToFireIndex].eventsToFire)                                        
                                            EventRegistry.SendEvent(s);                                        
                                        foreach (eventPackage ep in navPoints[patrolEventsToFireIndex].eventsToSend)
                                            EventRegistry.SendEvent(ep, gameObject);
                                    }
                                }
                            }
                        }
                        GoToNextPoint();
                    }
                }
                break;
            case BehaviorType.distracted:
                {
                    //NPC has arrived at distraction
                    if (!getAgentPathPending() && getAgentRemainingDistance() <= currentDistraction.minDistance) 
                    {
                        if(currentDistraction.NPCLookTarget != null)
                        {
                            Vector3 tempVec = currentDistraction.NPCLookTarget.transform.position - transform.position;
                            tempVec.y = 0;
                            transform.rotation  = Quaternion.LookRotation(tempVec, Vector3.up);                            
                        }
                        //TODO: set NPC senses dulled
                        distractionWaitTimer += Time.deltaTime;
                        if (distractionWaitTimer >=  currentDistraction.currentDuration)
                        {
                            endDistraction();
                        }
                    }
                }
                break;
        }
        

        _behaviorLastFrame = behaviorStack.Peek().behaviorType;
    }

    void followTarget()
    {
        if (behaviorStack.Peek().behaviorType == BehaviorType.following)
        {
            setAgentDestination(followFleeTarget.transform.position);            
            //if(!agent.pathPending && agent.remainingDistance >= followDistance)
            if (getAgentRemainingDistance() >= followDistance)
            {
                setAgentSpeed(patrolSpeed);                
            }
            else
            {
                setAgentSpeed(0);
            }
        }
    }

    float getDistanceToTarget(Transform target)
    {
        return ((transform.position - target.position).magnitude);
    }

    public bool canBeDistracted()
    {
        return ((currentDistractionCooldown == 0) && ((behaviorStack.Peek().behaviorType == BehaviorType.idle) || (behaviorStack.Peek().behaviorType == BehaviorType.patrolling)));

    }

    public void startDistraction(NPCDistractor npcd)
    {
        setAgentSpeed(patrolSpeed);
        currentDistraction = npcd;
        setBehavior(BehaviorType.distracted,npcd.gameObject);
        distractionWaitTimer = 0f;
        setAgentDestination(currentDistraction.NPCPlacementTarget.position);
    }

    public void endDistraction()
    {
        popBehaviorStack();        
        currentDistraction.finishDistraction();
        currentDistractionCooldown = UnityEngine.Random.Range(distractionCooldownMin, distractionCooldownMax);
    }

    void chaseTarget()
    {
        
        GameObject target = behaviorStack.Peek().behaviorTarget;
        float distanceToTarget = getDistanceToTarget(target.transform);

        switch (attackType)
        {
            case NPCAttackType.touch:
                setAgentDestination(target.transform.position);                
                break;
            case NPCAttackType.rangedProjectile:
                if ((distanceToTarget<= rangedAttackMaxDistance) && (distanceToTarget >= rangedAttackMinDistance) && currentObjectOfFocus.isVisible) // playerInSight)
                {
                    //TODO: add "last known position"
                    //agent.isStopped = true;
                    //TODO: level these out for body, but keep up/down for projectiles
                    Vector3 direction = (target.transform.position - transform.position).normalized;
                    Quaternion lookRotation = Quaternion.LookRotation(direction);
                    transform.rotation = lookRotation;
                    if (currentAttackCooldown <= 0)
                    {
                        fireProjectileAtTarget();
                        reacquiringTarget = false;
                    }//TODO: what does it do if it's in range but outside of the cooldown?
                }
                else
                {
                    //if(agent.remainingDistance > 0.5f)
                    if(!reacquiringTarget)
                        reacquire();
                    else
                    {
                        if ((agent.remainingDistance < 0.5f) && (reacquiringTarget))
                            reacquiringTarget = false;
                    }
                  
                }
                break;
            case NPCAttackType.melee:
                break;
        }
    }

    void reacquire()
    {
        Vector3 destinationPosition;
        Vector3 destinationOffset;
        Vector3 horizontalOffset;
        GameObject target = behaviorStack.Peek().behaviorTarget;
        Vector3 positionOffset = transform.position - target.transform.position;

        

        if (!reacquiringTarget)
        {
            float distance = positionOffset.magnitude;

            //float sweetspot = UnityEngine.Random.Range(rangedAttackMinDistance, rangedAttackMaxDistance);
            float sweetspot = (rangedAttackMinDistance + rangedAttackMaxDistance) / 2f;
            horizontalOffset = positionOffset.normalized * sweetspot;  //UnityEngine.Random.insideUnitCircle * 2f;

            destinationOffset = new Vector3(horizontalOffset.x, 0, horizontalOffset.z);

            destinationPosition = target.transform.position + destinationOffset;
            
            NavMeshHit hit;
            NavMesh.SamplePosition(destinationPosition, out hit, 2.5f, 1);
            destinationPosition = hit.position;
            reacquireDestination = destinationPosition;

            setAgentDestination(destinationPosition);
            
            reacquiringTarget = true;
            //nav.SetDestination(player.transform.position + ((transform.position - player.transform.position).normalized * rangedAttackMaxDistance));
        }
    }

    void fireProjectileAtTarget()
    {
        //TODO: turn to face player
        //TODO: wait for windup
        GameObject bulletObj = GameObject.Instantiate(bulletPrefab, transform.position + transform.forward * 1.5f, Quaternion.identity);
        bulletObj.transform.parent = null;
        if (bulletObj.GetComponent<BulletBehavior>() != null)
        {
            bulletObj.GetComponent<BulletBehavior>().init(transform.forward);
            currentAttackCooldown = attackcoolDownMax;
            if ((rangedAttackSound != null) && (enemyAudioSource != null))
            {
                enemyAudioSource.clip = rangedAttackSound;
                enemyAudioSource.Play();
            }
        }
        //TODO: make this a random value between the min and max
    }

    void setFleePoint()
    {
        //TODO: make this not terrible
        Vector3 fleePos;
        Vector2 fleeOffset;
        if (fleePoints.Count == 0)
        {
            float dist = (transform.position - player.transform.position).magnitude;
            fleeOffset = (UnityEngine.Random.insideUnitCircle).normalized * dist * 2;
            fleePos = transform.position + new Vector3(fleeOffset.x, 0, fleeOffset.y);

            NavMeshHit hit;
            NavMesh.SamplePosition(fleePos, out hit, 10.0f, 1);
            setAgentDestination(hit.position);            
        }
        else
        {
            setAgentDestination(getFurthestFleePointFromPlayer());            
        }
    }

    Vector3 getFurthestFleePointFromPlayer()
    {
        Vector3 playerLoc = player.transform.position;
        Vector3 farthestPoint = transform.position;
        float dist = 0;
        foreach (GameObject go in fleePoints)
        {
            if ((go.transform.position - playerLoc).magnitude > dist)
            {
                farthestPoint = go.transform.position;
                dist = (go.transform.position - playerLoc).magnitude;
            }
        }
        return farthestPoint;
    }

    void fleePlayer()
    {
        if (getAgentRemainingDistance() <= 1.0f)
            setFleePoint();
    }

    private bool checkIsOOIInList(GameObject obj)
    {
        foreach(OOIProfile op in objectsOfInterest)
        {
            if(obj == op.OOI.gameObject)
            {
                return true;
            }            
        }
        return false;
    }

    OOIProfile AddOOIToList(GameObject other)
    {
        OOIProfile tempOP;
        EnemyBehavior tempEb;
        GAME1304PlayerController tempPc;

        tempOP = new OOIProfile();
        tempOP.OOI = other.gameObject.GetComponent<ObjectOfInterest>();

        tempOP.frameOfReference = OOIFrameOfReference.direct;
        tempOP.awarenessLevel = 0;
        tempOP.category = OOICategory.unknown;

        //See if it's another NPC
        tempEb = other.gameObject.GetComponent<EnemyBehavior>();
        if (tempEb != null)
        {
            if (NPCManager.factionRelationships.ContainsKey(faction))
            {
                if (NPCManager.factionRelationships[faction] != null)
                    tempOP.attitude = NPCManager.factionRelationships[faction][tempEb.faction];
                else
                    tempOP.attitude = Attitude.neutral;
            }
            else
            {
                Debug.Log("ERROR in faction database");
                tempOP.attitude = Attitude.neutral;
            }

            switch (tempOP.attitude)
            {
                case Attitude.fearful:
                    tempOP.category = OOICategory.threat;
                    break;
                case Attitude.friendly:
                    tempOP.category = OOICategory.ally;
                    break;
                case Attitude.hostile:
                    tempOP.category = OOICategory.threat;
                    break;
                case Attitude.neutral:
                    tempOP.category = OOICategory.ally;
                    break;
            }
            
        }
        else
        {
            
            //See if it's the player
            tempPc = other.gameObject.GetComponent<GAME1304PlayerController>();
            if (tempPc != null)
            {
                if (NPCManager.factionRelationships.ContainsKey(faction))
                {
                    if (NPCManager.factionRelationships[faction] != null)
                        tempOP.attitude = NPCManager.factionRelationships[faction][Faction.player];
                    else
                        tempOP.attitude = Attitude.neutral;
                }
                else
                {
                    Debug.Log("ERROR in missing faction entry");
                    tempOP.attitude = Attitude.neutral;
                }
                
                switch (tempOP.attitude)
                {
                    case Attitude.fearful:
                        tempOP.category = OOICategory.threat;
                        break;
                    case Attitude.friendly:
                        tempOP.category = OOICategory.ally;
                        break;
                    case Attitude.hostile:
                        tempOP.category = OOICategory.threat;
                        break;
                    case Attitude.neutral:
                        tempOP.category = OOICategory.ally;
                        break;
                }
            }
        }

        objectsOfInterest.Add(tempOP);
        return tempOP;
    }
    private void OnTriggerEnter(Collider other)
    {
       

        if (GameManager.isPaused || _currentHealth <= 0)
            return;
        
        //this thing is something the NPC cares about
        if (other.gameObject.GetComponent<ObjectOfInterest>())
        {
            if (!checkIsOOIInList(other.gameObject))
            {
                AddOOIToList(other.gameObject);
                
            }
        }
    }

    //objects within the field of view
    void OnTriggerStay(Collider other)
    {
        OOIProfile tempOP;
        
        if (GameManager.isPaused || _currentHealth <= 0)
            return;
        if (other.isTrigger)
            return;

        //this thing is something the NPC cares about
        if(!other.gameObject.GetComponent<ObjectOfInterest>())
        {
            return;
        }

        tempOP = new OOIProfile();
        if (checkIsOOIInList(other.gameObject))
        {
            foreach (OOIProfile op in objectsOfInterest)
            {
                if (op.OOI.gameObject == other.gameObject)
                    tempOP = op;
            }
        }
        else
            tempOP = AddOOIToList(other.gameObject);

        float testFOV;        
        if (behaviorStack.Peek().behaviorType == BehaviorType.attacking)
            testFOV = pursuitFOV;
        else
            testFOV = patrolFOV;

        tempOP.isVisible = false;
            
        Vector3 direction = other.transform.position - transform.position;
        float angle = Vector3.Angle(direction, transform.forward);

        if (angle < (testFOV * 0.5f))
        {
            RaycastHit hit;
            //TODO: offset the raycast by the character's half height instead of just 1
            //LayerMask mask = LayerMask.GetMask("Player");
            if (Physics.Raycast(transform.position + transform.up, direction.normalized, out hit, visionSphere.radius)) //,mask.value))
            {
                if (hit.collider.gameObject == other.gameObject)
                {
                    tempOP.isVisible = true;

                }
            }
            if (Physics.Raycast(transform.position, direction.normalized, out hit, visionSphere.radius)) //,mask.value))
            {
                if (hit.collider.gameObject == other.gameObject)
                {
                    tempOP.isVisible = true;

                }
            }
        }
    }
    

    void GoToNextPoint()
    {
        //if we've been given bad data, exit
        //should probably pop an assert here as well
        setAgentStopped(false);        
        patrolWaitTimer = 0;
        if ((navPoints == null)||(navPoints.Count==0))
        {
            setBehavior(BehaviorType.idle,null);
            return;
        }
        if (navPoints.Count <= 0)
        {
            setBehavior(BehaviorType.idle,null);
            return;
        }
        setAgentDestination(navPoints[currentPointIndex].navPointObject.transform.position);        
        patrolEventsToFireIndex = currentPointIndex;
        switch (patrolType)
        {
            case navBehavior.patrolLoop:
                currentPointIndex += 1;
                if (currentPointIndex >= navPoints.Count)
                    currentPointIndex = 0;
                break;
            case navBehavior.patrolPingPong:
                currentPointIndex += pingPongDir;
                if (currentPointIndex >= navPoints.Count)
                {
                    pingPongDir = -1;
                    currentPointIndex = navPoints.Count - 2;
                }
                else if (currentPointIndex < 0)
                {
                    pingPongDir = 1;
                    currentPointIndex = 1;
                }
                break;
            case navBehavior.wander:
                currentPointIndex = UnityEngine.Random.Range(0, navPoints.Count);
                break;
        }
    }

    public void setAgentStopped(bool isStopped)
    {
        if (!isFlying)
        {
            agent.isStopped = isStopped;
        }
        else
        {
            if (flyBehavior != null)
                flyBehavior.setIsStopped(isStopped);
        }
    }

    public void setAgentSpeed(float speed)
    {
        if(!isFlying)
            agent.speed = speed;
        else
        {
            if (flyBehavior != null)
                flyBehavior.setSpeed(speed);
        }
    }

    public void setAgentDestination(Vector3 destination)
    {
        if(!isFlying)
        {
            agent.SetDestination(destination);            
        }
        else
        {
            if (flyBehavior != null)
                flyBehavior.setDestination(destination);
        }
    }

    public float getAgentRemainingDistance()
    {
        if (!isFlying)
        {
            return agent.remainingDistance;
        }
        else
        {
            if (flyBehavior != null)
                return flyBehavior.getRemainingDistance();            
        }
        return -1;
    }

    public bool getAgentPathPending()
    {
        if (!isFlying)
        {
            return agent.pathPending;
        }
        else
        {
            if (flyBehavior != null)
                return flyBehavior.getPathPending();
        }
        
        return true;
    }

    public void setAgentEnabled(bool enabled)
    {
        if (!isFlying)
        {
            agent.enabled = enabled;
        }
        else
        {
            if (flyBehavior != null)
                flyBehavior.enabled = enabled;
        }        
    }
}